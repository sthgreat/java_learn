哈希函数处理冲突的方法：
1.开放定址法：通俗来说就是在当前计算的hash值位置上已经有其他数据的时候，对原数据做相同操作的修改后使用散列算法进行再次分配位置直到找到没有数据的位置
    线性探测再散列   di = 1 , 2 , 3 , … , m-1
    平方探测再散列   di = 1 2 , -12 , 22 , -22 , 32 , -32 , … , k2 ,  -k2
    
2.链地址法：通俗来说就是如果发现当前的位置有人，那么在当前位置的数据后面接入链表，将后来的数据放在链表中

#---------------------#
HashMap
  HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。
  HashMap继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。
  HashMap的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null，其中HashMap最多只允许一条记录的键为Null，允许多条记录的值为Null。此外，HashMap中的映射不是有序的。
  HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。
  通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。

LinkedHashMap
  LinkedHashMap是HashMap的子类，但是内部还有一个双向链表维护键值对的顺序，每个键值对既位于哈希表中，也位于双向链表中。LinkedHashMap支持两种顺序插入顺序 、 访问顺序
  1.插入顺序：先添加的在前面，后添加的在后面。修改操作不影响顺序
  2.访问顺序：所谓访问指的是get/put操作，对一个键执行get/put操作后，其对应的键值对会移动到链表末尾，所以最末尾的是最近访问的，最开始的是最久没有被访问的，这就是访问顺序。

TreeMap:
  纠正一下，TreeMap实现一定顺序是通过Comparable接口的，而他实现元素不重复也是完全通过compareTo，而不是hashCode和equals，因为debug不会走到hashCode和equals方法，但是会走compareTo方法

LRU的整体思路是：淘汰最长时间未使用的页面（key）
   这里使用LinkedHashMap的第二种排序方法即可实现。
#----------------------#
