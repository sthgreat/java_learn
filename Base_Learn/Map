哈希函数处理冲突的方法：
1.开放定址法：通俗来说就是在当前计算的hash值位置上已经有其他数据的时候，对原数据做相同操作的修改后使用散列算法进行再次分配位置直到找到没有数据的位置
    线性探测再散列   di = 1 , 2 , 3 , … , m-1
    平方探测再散列   di = 1 2 , -12 , 22 , -22 , 32 , -32 , … , k2 ,  -k2
    
2.链地址法：通俗来说就是如果发现当前的位置有人，那么在当前位置的数据后面接入链表，将后来的数据放在链表中

#---------------------#
HashMap
  HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。
  HashMap继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。
  HashMap的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null，其中HashMap最多只允许一条记录的键为Null，允许多条记录的值为Null。此外，HashMap中的映射不是有序的。
  HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。
  通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。

LinkedHashMap
  LinkedHashMap是HashMap的子类，但是内部还有一个双向链表维护键值对的顺序，每个键值对既位于哈希表中，也位于双向链表中。LinkedHashMap支持两种顺序插入顺序 、 访问顺序
  1.插入顺序：先添加的在前面，后添加的在后面。修改操作不影响顺序
  2.访问顺序：所谓访问指的是get/put操作，对一个键执行get/put操作后，其对应的键值对会移动到链表末尾，所以最末尾的是最近访问的，最开始的是最久没有被访问的，这就是访问顺序。

TreeMap:
  纠正一下，TreeMap实现一定顺序是通过Comparable接口的，而他实现元素不重复也是完全通过compareTo，而不是hashCode和equals，因为debug不会走到hashCode和equals方法，但是会走compareTo方法

LRU的整体思路是：淘汰最长时间未使用的页面（key）
   这里使用LinkedHashMap的第二种排序方法即可实现。
#----------------------#

HashMap 的长度为什么是2的幂次方
为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648到2147483647，前后加起来大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ (n - 1) & hash”。（n代表数组长度）。这也就解释了 HashMap 的长度为什么是2的幂次方。

！！！装逼警告！：同时，hashmap在扩容时，根据n（二倍后，即二进制往右加一个1） & hash计算位置，如若hash值该位是0，则位置不变，如若hash值该位是1，则
数组下标直接加上n/2移动到对应位置，简单轻松！ 

这个算法应该如何设计呢？

我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&)操作（也就是说 hash%length==hash&(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。
