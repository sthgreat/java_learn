构成： 方法区域，堆，虚拟机栈，本地方法栈，程序计数器

程序计数器：线程私有，一块较小的内存空间，可以被看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是改变这个计数器的值来选取下一条需要
          执行的字节码指令，分支、循环、跳转、异常处理等基础功能都要依赖这个计数器来完成。
         
JAVA虚拟机栈：线程私有生命周期与线程相同。Java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧，用于存储局部变量表、操作数栈等信息。当进入
一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的。

本地方法栈：与虚拟机栈相似，不同点在于虚拟机栈为虚拟机执行Java方法服务，本地方法栈为虚拟机使用的Native方法服务。

堆：所有线程共享的一块内存区域，在虚拟机启动时创建，用来存放对象实例，所有的对象实例都在这里分配内存。是垃圾收集器管理的主要区域。
   现在来说收集器基本采用分代收集算法。在堆中还可细分为新生代、老年代、持久代。

方法区：各个线程共享的内存区域，存储已被虚拟机加载的类信息，常量，静态变量等数据。
#------------------------------#
一. 什么是Native Method
   简单地讲，一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：
   该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C＋＋中，
   你可以用extern "C"告知C＋＋编译器去调用一个C的函数。


二、对象访问定位
Java程序需要通过栈上的reference数据来操作堆上的具体对象。
两种方式：使用句柄，直接指针。

句柄访问：
Java堆划分出一块内存来作为句柄池。句柄中包含了对象实例数据与类型数据各自的具体地址信息。
优势：存储稳定的句柄地址，对象被移动时只会改变句柄中的实例数据指针。

指针访问：
堆对象中包含到对象类型数据的指针。
优势：速度更快，节省一次指针定位的时间开销。

#-------------------------------#
JVM三大参数：

-Xms:设置初始分配大小，默认为物理内存的“1/64”
-Xmx:最大分配内存，默认为物理内存的“1/4”
-Xss规定了每个线程堆栈的大小。一般情况下256K是足够了。影响了此进程中并发线程数大小。
