Java的垃圾回收技术，负责回收不用的对象，释放内存，避免内存泄漏与内存溢出情况。

算法：
1.引用计数算法：给对象添加一个引用技术器。每当有个地方引用它，计数器增加一；当引用失效，计数器减少一。任何时刻，计数器为0的对象就表示不可能再被引用。
  缺点：很难解决对象间循环引用的情况。如A引用B，B引用A，除此之外两个对象再无其他引用。
  
2.可达性算法：通过一系列被称为“GC Roots”的对象作为起始点从这些节点开始往下搜索，搜索走过的路经被称为引用链，当一个对象到达GC Roots没有任何引用链
  相连，证明该对象不可用。
  可作为GC Roots的对象包括下面几种：a.虚拟机栈中引用的对象
                                 b.方法区中类静态属性引用的对象
                                 c.方法区中常量引用的对象
                                 d.本地方法栈中引用的对象
                                 
引用的四种类型:强引用,软引用,弱引用,虚引用

#-----------------------#
方法区回收:
集中回收两个部分:1.废弃的常量;2.无用的类
常量池中某个常量没有被任何一个类对象引用,则可以被回收
类的回收需要满足三个条件:1.该类的所有实例已经被回收;2.加载该类的ClassLoader已经被回收;3.该类对应的java.lang.Class对象没有在任何地方被引用,无法在任何地方通过
反射访问该类的方法.

#-----------------------#
回收算法:
标记-清除（major gc，回收老年代）：会产生空间碎片，可能导致大对象无法分配而提前触发GC

复制算法（minor gc，回收新生代）

标记-整理

分代收集算法（不同代使用不同回收算法）

#-----------------------#
强引用：拥有强引用的对象任何时候不会被GC回收

软引用：只有在内存吃紧的时候会被GC回收
  软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。
 （1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建
 （2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出
  这时候就可以使用软引用

弱引用:GC触发即被回收，但是由于GC是优先度较低的线程，在正常运行情况下一般不会立即被发现

#------------------------#
G1收集器：
老年代采用标记-整理算法

CMS收集器：
老年代采用标记-清除算法，低停顿
#-----------------------#
Minor GC：发生在新生代的垃圾回收

大对象直接进入老年代
长期存活对象将进入老年代
新生代主要使用复制算法，因此会分为两个部分

#-------------------------#
空间分配担保：
  在每一次minorGC发生之前，会先检查老年代最大连续空间是否大于新生代的所有对象总和，如果大于，安全，可以发生minorGC。如果小于，检查jvm设置是否允许
担保失败，若不允许允许，直接fullGC；如果允许，检查老年代最大连续空间是否大于每次晋升上来的对象大小总和的平均，小于，fullGC，大于，尝试minorGC。

#-------------------------#
MinorGC触发条件
虚拟机在进行minorGC之前会判断老年代最大的可用连续空间是否大于新生代的所有对象总空间

    1、如果大于的话，直接执行minorGC

    2、如果小于，判断是否开启HandlerPromotionFailure，没有开启直接FullGC

    3、如果开启了HanlerPromotionFailure, JVM会判断老年代的最大连续内存空间是否大于历次晋升（晋级老年代对象的平均大小）平均值的大小，如果小于直接执行FullGC

    4、如果大于的话，执行minorGC
    
FullGC触发条件
1.老年代空间不足
     如果创建一个大对象，Eden区域当中放不下这个大对象，会直接保存在老年代当中，如果老年代空间也不足，就会触发Full GC。为了避免这种情况，最好就是不要创建太大的对象。

2.持久代空间不足
    如果有持久代空间的话，系统当中需要加载的类，调用的方法很多，同时持久代当中没有足够的空间，就出触发一次Full GC

3.YGC出现promotion failure
    promotion failure发生在Young GC, 如果Survivor区当中存活对象的年龄达到了设定值，会就将Survivor区当中的对象拷贝到老年代，如果老年代的空间不足，就会发生promotion failure， 接下去就会发生Full GC.

4.统计YGC发生时晋升到老年代的平均总大小大于老年代的空闲空间
      在发生YGC是会判断，是否安全，这里的安全指的是，当前老年代空间可以容纳YGC晋升的对象的平均大小，如果不安全，就不会执行YGC,转而执行FullGC。

5.显示调用System.gc
