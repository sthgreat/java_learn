1. 只保证可见性，在以下两条规则的运算场景中，我们仍然要通过加锁来保证原子性。

    a.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
    b.变量不需要与其他的状态变量共同参与不受约束
    
2. 禁止指令重排序优化（刷新内存，将本CPU的cache（高速缓存）中的内容存入内存中（该部分赋值代码已经完成），以此防止cpu执行代码的时候进行的指令重排序）

与普通变量不同的是：新值能立即同步到主内存，每次使用前立即从主内存刷新


线程内表现为串行，一个线程中观察另一个线程，所有操作无序。

为什么volatile变量的自加操作不是原子性的：
    1.volatile变量仅仅只能保证可见性（在将工作内存的数据写入主内存时通知其他线程，让其中的缓存失效）
    2.虚拟机的（volatile）操作中规定：其一，线程T对变量V执行的前一个动作是load时，才能对变量执行use动作，并且，只有线程T对
    变量V执行的后一个操作时use时，线程T才能对变量执行load操作（load->use 绑定，连续一起出现，load后必须是use，故会出现不能更改，表面上与缓存一致性协议相违背。每次
    使用V前都必须先从主内存刷新最新的值，用于保证能看到其他线程对变量V所做的修改后的值）;其二，assign->store（每次修改V后都必须立刻同步回主内存中，
    用以保证其他线程能够看到自己对变量V的修改）（此处满足缓存一致性协议，修改主内存的某一地址值时，使其他线程本地内存中的volatile变量失效，即第一条，
    使用前都要重新读取）；其三，线程T对变量V所做的一系列操作要合乎顺序（load->use->assign->store）（保证被volatile修饰的变量不会被指令重排序优化，
    保证代码的执行顺序与程序的顺序相同）。
