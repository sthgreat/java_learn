线程安全：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作
，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。

绝对线程安全：不管运行时环境如何，调用者都不需要任何额外的同步措施。

自旋锁：避免线程切换（挂起、恢复）所带来的开销。占用处理器时间，富国锁被占用的时间很短，效果很好。
      自适应：记录前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定。p398

内存屏障：将之前更改的数据直接刷新进入主内存。（缓存数据全部输入内存）（并发编程p26）

重排序：编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。（排序不具有数据依赖的指令）

Mark Word(标记字段)：用于存储运行时对象自身的数据，相当于线程在运行时贴上自己的标签，别的线程不可用，其占用内存大小与虚拟机位长一致，在运行期间，考虑到JVM的空间效率，Mark Word被设计成为一个非固定的数据结构，以便存储更多有效的数据。锁相关


原子类：
    Java从JDK1.5开始提供了java.util.concurrent.atomic包，方便程序员在多线程环境下，无锁的进行原子操作。原子变量的底层使用了处理器提供的原子指令，但是不同的CPU架构可能提供的原子指令不一样，也有可能需要某种形式的内部锁,所以该方法不能绝对保证线程不被阻塞。
    原子类其内部实现不是简单的使用synchronized，而是一个更为高效的方式CAS (compare and swap) + volatile和native方法（同步的工作更多的交给了硬件），从而避免了synchronized的高开销，执行效率大为提升
    虽然基于CAS的线程安全机制很好很高效，但要说的是，并非所有线程安全都可以用这样的方法来实现，这只适合一些粒度比较小，型如计数器这样的需求用起来才有效，否则也不会有锁的存在了
