避免死锁的方法：
1、避免一个线程同时获取多个锁
2、避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
3、尝试使用定时锁
4、对于数据库锁，加锁和解锁必须在一个数据库连接中，否则会出现解锁失败的情况

#------------------------#
Volatile关键字
如果一个字段被声明为volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。
#------------------------#
重入锁：
一个线程在获取锁的情况下，再次请求获取锁时可被允许。（支持一个线程对资源的重复加锁，用于递归等场景）。

synchronized关键字隐式地实现了重入锁。
ReetrantLock：（排他锁，解锁操作尽量放在finally代码块中，保证线程正确释放锁）。
  与synchronized的区别：1.更加灵活，可以实现公平锁（synchronized是非公平锁）;2.可以响应中断：synchronized实现锁时，阻塞在锁上的线程除非获得锁，
                      否则将一直等待下去。而reentrantlock提供响应中断获取锁的方法，可以解决死锁问题。
  
公平锁：当前占有锁的线程释放锁后，同步队列中的下一个线程获取锁。（避免线程“饥饿”情况）
非公平锁：当前占有锁的线程释放锁后，同步队列中的所有线程竞争锁。（性能高）

  ReentrantReadWriteLock:读写锁，依赖自定义的同步器来实现同步功能，读写状态就是其同步器的同步状态。
  读锁是多线程共享，所做的只是增加读状态，在没有其他写线程访问或者写状态为0时，总是能获取到读锁。
  写锁是支持重进入的排他锁，如果在获取时，读锁已经被获取或者该线程不是已经获取读锁的线程，当前线程进入等待状态。
  锁降级：当前线程把持写锁，然后获取读锁，最后释放写锁。
