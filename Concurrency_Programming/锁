避免死锁的方法：
1、避免一个线程同时获取多个锁
2、避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
3、尝试使用定时锁
4、对于数据库锁，加锁和解锁必须在一个数据库连接中，否则会出现解锁失败的情况

#------------------------#
Volatile关键字
如果一个字段被声明为volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。
#------------------------#
重入锁：
一个线程在获取锁的情况下，再次请求获取锁时可被允许。（支持一个线程对资源的重复加锁，用于递归等场景）。

synchronized关键字隐式地实现了重入锁。
ReetrantLock：（排他锁，解锁操作尽量放在finally代码块中，保证线程正确释放锁）。
  与synchronized的区别：1.更加灵活，可以实现公平锁（synchronized是非公平锁）;2.可以响应中断：synchronized实现锁时，阻塞在锁上的线程除非获得锁，
                      否则将一直等待下去。而reentrantlock提供响应中断获取锁的方法，可以解决死锁问题。
  
公平锁：当前占有锁的线程释放锁后，同步队列中的下一个线程获取锁。（避免线程“饥饿”情况）
非公平锁：当前占有锁的线程释放锁后，同步队列中的所有线程竞争锁。（性能高）
