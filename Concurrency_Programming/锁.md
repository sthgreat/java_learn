避免死锁的方法：
1、避免一个线程同时获取多个锁
2、避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
3、尝试使用定时锁
4、对于数据库锁，加锁和解锁必须在一个数据库连接中，否则会出现解锁失败的情况

#------------------------#
Volatile关键字
如果一个字段被声明为volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。
#------------------------#
重入锁：
一个线程在获取锁的情况下，再次请求获取锁时可被允许。（支持一个线程对资源的重复加锁，用于递归等场景）。

synchronized关键字隐式地实现了重入锁。
ReetrantLock：（排他锁，解锁操作尽量放在finally代码块中，保证线程正确释放锁）。
  与synchronized的区别：1.更加灵活，可以实现公平锁（synchronized是非公平锁）;2.可以响应中断：synchronized实现锁时，阻塞在锁上的线程除非获得锁，
                      否则将一直等待下去。而reentrantlock提供响应中断获取锁的方法，可以解决死锁问题。
  
公平锁：当前占有锁的线程释放锁后，同步队列中的下一个线程获取锁。（避免线程“饥饿”情况）
非公平锁：当前占有锁的线程释放锁后，同步队列中的所有线程竞争锁。（性能高）

  ReentrantReadWriteLock:读写锁，依赖自定义的同步器来实现同步功能，读写状态就是其同步器的同步状态。
  读锁是多线程共享，所做的只是增加读状态，在没有其他写线程访问或者写状态为0时，总是能获取到读锁。
  写锁是支持重进入的排他锁，如果在获取时，读锁已经被获取或者该线程不是已经获取读锁的线程，当前线程进入等待状态。
  锁降级：当前线程把持写锁，然后获取读锁，最后释放写锁。

============================
Reentrantlock 与 synchronized区别：
1. reentrantlock比synchronized在使用上更加灵活
2. reentrantlock可使用公平锁与非公平锁，synchronized只有非公平锁
3. reentrantlock基于jdk实现，synchronized基于jvm实现

==============================
悲观锁
总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。

乐观锁
总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。

两种锁的使用场景
从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。

=========================================
synchronized关键字实现的锁：
偏向锁和轻量级锁均在栈中使用lock record来记录锁的使用
lock record中包含有轻量级锁的displace mark word
lock record关乎偏向锁和轻量级锁中的重入判定，通过遍历栈中的lock record数量可以得到是否是重入状态。
其中偏向锁的释放很简单，只需要释放lock record即可，后续线程获取偏向锁的时候会检查当前线程是否还活着，如果线程已死或不在同步块中，可设置重偏向（重新将对象设置为匿名偏向）或者将对象设置为无锁状态；否则如果在同步块中，偏向锁升级为轻量级锁。
偏向锁升级为轻量级锁：先将对象的markword替换为轻量级锁的形式（当前持有锁的线程需要在同步块中），再找到当前的线程，将其中的最上面的lock record中的displaced mark word设置为轻量级锁的形式
轻量级锁膨胀为重量级锁：当前线程中的displaced mark word 替换为特殊标识，同时初始化一个monitor对象，将对象的锁记录指向这个monitor对象，
monitor对象中的header属性保存了displaced mark word，obj属性保存了该对象，还保存了指向栈中的lock record的指针。

=========================================
reentranlock实现的非公平锁：
新线程进来只有两次cas抢夺锁的机会，都失败的话会进入同步队列自旋，自旋中就需要检查自身是否为同步队列中的头节点了。是头节点才可以尝试获取锁。
