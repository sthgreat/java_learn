Lock的使用方式：
  Lock lock = new ReentrantLock();
  lock.lock();
  try{
    ...
  }finally{
    lock.unlock();
  }
  
  1.在finally块中释放锁，保证锁最后能被释放。
  2.不将获取锁写在try中。因为在获取锁时发生异常，异常抛出的同时，锁会被无故释放。
  特性： A.可以尝试非阻塞地获取锁
        B.能被中断地获取锁


  reentrantlock的公平锁与非公平锁：区别在于，公平锁在获取锁的过程中需要观察当前节点（等待线程构造而成的节点）是否有前驱节点。而非公平锁不需要这一判断。


  AQS队列同步器：AQS提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架，完成线程同步。以队列同步器为基础实现的锁，在某一线程通过CAS操作获得
  同步状态时，在上层表现出来的即为获得了锁。

  每个Condition对象包含一个等待队列，队列的每个节点都包含了一个线程的引用。节点在更新时没有用CAS操作保证线程安全，因为调用await()方法的线程必定是
  获取了锁的线程，该过程由锁来保证线程安全。
  
  从队列角度看await()方法，当调用该方法时，同步队列的首节点移动到Condition的等待队列中。--addConditionWaiter
  
  调用Condition的signal()方法将会唤醒等待队列中的首节点，将其移动到同步队列中。signalAll()方法会将等待队列中的所有节点执行一次signal()方法。
  
  从等待队列返回：当前持有lock锁的线程调用某一个Condition的signal(signalAll方法)，将该Condition中的等待队列首节点(所有节点)移动到同步队列，然后使用
  LockSupport唤醒节点中的线程。被唤醒的线程会首先退出await方法中的循环（循环的判断条件为是否在同步队列中），进而调用同步器的acquireQueued()方法加入
  到同步状态的竞争中。成功获取锁之后，被唤醒的线程从先前调用的await方法中返回。
  
  
  总结：
.1. lock的实现是在一个class里面的，所以在每个class的实例化对象里面都存在对应的 同步队列 以及 等待队列。
.2. 假如在一个class里面有多个 实现 lock 的类的内部变量，针对不同的方法，但是一个对象仍然只有一把锁，凡是没有获取到锁的都进入到同步队列（synchronized 关键字是对象的同步队列 !!!but!!! lock.lock（）是同步器的同步队列,但是同步器中的同步队列是自旋非阻塞的）
.
.3. 同步队列， 首先是获取锁失败，调用park阻塞线程，封装为Node ，然后CAS添加到队列的末尾，然后 在同步队列里面，有头结点的下一个节点被remove掉之后，显式的 调用了 unpark 方法唤醒后继节点去获取锁。这里锁的获取是没有 自旋 的，Node 加入尾部是在CAS循环的。
.4. 等待队列，是已经获取到锁的线程，需要用到其他线程的数据，主动调用 wait() 方法，并且释放锁，唤醒同步队列的后继节点（非公平不用唤醒），然后当前节点构造新的Node进入等待队列，当有其他 在同步队列里面 已经获得锁的线程调用 notify()（或者 signal()）之后，才会重新加入同步队列，尝试获取锁。 等待队列的节点也调用了 park () 方法阻塞。
.5. 唤醒同步队列中的后继被阻塞的节点，是通过 lockSupport()（本文后面） 中的 unpark()方法唤醒被阻塞线程。park()阻塞。
.6. 在ReetrantLock 里面，有公平与非公平自旋锁，也是基于 同步器的，同步器的队列是默认阻塞的 ，ReetrantLock 里面是自旋非阻塞的。 ----- 但是 ， 非公平的自旋锁，其实是真的在自旋，不会阻塞住， 但是公平的，本来就是按照 FIFO 的方式，直接使用 同步器的FIFO，同步队列里面 前一个unpark 后一个不就行了吗 ？？？ 应该不存在 自旋这个概念才对 。 但是实际上是，一直在自旋，但是获取的条件多了一个 判断当前节点是不是第一个节点 。 是则获取 。 ------- 所以 ReetrantLock 里面 公平与非公平的 自旋锁，都是在一直自旋没有 park（）， 但是 非公平的多了判断是否是头结点 。
